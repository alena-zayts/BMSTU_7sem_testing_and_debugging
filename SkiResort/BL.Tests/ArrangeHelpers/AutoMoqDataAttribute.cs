using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using AutoFixture.Xunit2;
using AutoFixture.AutoMoq;

namespace BL.Tests
{
    public class AutoMoqDataAttribute : AutoDataAttribute
    {
        public AutoMoqDataAttribute()
            : base(new AutoFixture.Fixture().Customize(new AutoMoqCustomization()))
        { }
    }

    /*
     * AutoFixture умеет создавать экземпляры разных, в общем случае сколь угодно сложных типов. 
     * Примитивные типы создаются с помощью встроенных генераторов.
     * Для пользовательских типов выбирается конструктор с минимальным количеством параметров, 
     * значение для каждого параметра рекурсивно генерится тем же AutoFixture. 
     * В дополнение к этому AutoFixture по умолчанию вызовет все публичные сеттеры свойств класса, 
     * в качестве значений передав опять же сгенерированные самим собой объекты. Тем самым на выходе мы получаем объект, 
     * заполненный некими случайными значениями. 
     */

    /*
     * AutoMoqCustomization это одна из настроек, которая «учит» AutoFixture делать простую вещь: 
     * если ни одним из способов не удалось создать требуемый экземпляр и тип объекта является либо интерфейсом,
     * либо абстрактным классом, то AutoFixture создает мок, используя Moq. 
     * Звучит классно, создаем сервис через AutoFixture и все его зависимости уже проинициализированы. 
     * Одна проблема, иногда моки нужно настраивать и проверять, что там было вызвано. 
     * Где взять экземпляр мока собственно? Здесь на помощь приходит еще один механизм AutoFixture, 
     * называемый Freeze. Суть его в том, чтобы запомнить какое-то определенное значение для типа объекта и 
     * возвращать именно его (вместо генерации нового) каждый раз, когда он потребуется при генерации других объектов.
     */
}
